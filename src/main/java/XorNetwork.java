/*
 * This Java source file was auto generated by running 'gradle buildInit --type java-library'
 * by 'colin_000' at '09/03/18 8:44 PM' with Gradle 2.14.1
 *
 * @author colin_000, @date 09/03/18 8:44 PM
 */

import Jama.Matrix;

public class XorNetwork {
	
	private class Node{
		// Weights is a column vector
		private Matrix weights;
		private double bias;
		
		public Node(int numWeights, boolean isInput){
			
			// If input node, no need to have bias or non-one weights
			if(isInput){
				weights = new Matrix(1, 1, 1);
				bias = 0;
			} else {
				weights = Matrix.random(numWeights, 1);
				
				bias = Math.random();
			}
		}
		
		public double takeInput(double inputs[]){
			
			// The inputs become a row vector
			double inputsTemp[][] = new double[1][];
			inputsTemp[0] = inputs;
			
			Matrix inputsVector = new Matrix(inputsTemp);
			
			Matrix output = inputsVector.times(weights);
			
			return sigmoid(output.get(0, 0) + bias);
		}
		
		private double sigmoid(double x){
			double ex = Math.exp(x);
			return ex / (ex + 1);
		}
	}
	
	private Node[][] layersNodesWeightsBias;
	
	public XorNetwork(int numNodesInLayers[]) {
		
		// Add correct number of layers
		layersNodesWeightsBias = new Node[numNodesInLayers.length][];
		
		// Add correct number of nodes, and then add weights and bias
		for(int i = 0; i < numNodesInLayers.length; ++i)
		{
			// Create correct number of nodes
			layersNodesWeightsBias[i] = new Node[numNodesInLayers[i]];
			
			// Initialize each node
			for(int k = 0; k < numNodesInLayers[i]; ++k)
			{
				if(i == 0){
					layersNodesWeightsBias[i][k] = new Node(1, true);
				} else {
					layersNodesWeightsBias[i][k] = new Node(numNodesInLayers[i - 1], false);
				}
			}
		}
    }
	
	// Get inputs to the network, return outputs of the network
	public double[] goThroughNetwork(double inputs[])
	{
		double outputs[] = null;
		double layerInputs[] = arrayCopy(inputs);
		
		//For each layer, multiply inputs by the weights + bias, then send outputs to next layer
		for(int layerNum = 0; layerNum < layersNodesWeightsBias.length; ++layerNum){
			Node[] layer = layersNodesWeightsBias[layerNum];
			
			outputs = new double[layer.length];
			
			// For each node, multiple inputs by weights then add bias
			for(int nodeNum = 0; nodeNum < layer.length; ++nodeNum){
				
				// If this is the input node, then match each input with a node
				if(layerNum == 0){
					double singleInput[] = new double[1];
					singleInput[0] = layerInputs[nodeNum];
					
					outputs[nodeNum] = layer[nodeNum].takeInput(singleInput);
				} else {
					outputs[nodeNum] = layer[nodeNum].takeInput(layerInputs);
				}
			}
			
			// Convert the outputs into the inputs for the next layer
			layerInputs = arrayCopy(outputs);
		}
		
		return outputs;
	}
	
	//Convenience function
	private double[] arrayCopy(double orig[]){
		double copy[] = new double[orig.length];
		
		for(int i = 0; i < orig.length; ++i){
			copy[i] = orig[i];
		}
		
		return copy;
	}
}
